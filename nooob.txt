const userMessages = new Set(); // Track users for broadcasting
const startTime = Date.now(); // Track bot start time
let messageCount = 0; // Track the number of messages processed

addEventListener('fetch', event => {
    event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
    let body;
    try {
        body = await request.json();
    } catch (e) {
        console.error('Error parsing JSON:', e);
        return new Response('Invalid JSON', { status: 400 });
    }

    if (body.message) {
        const chatId = body.message.chat.id;
        const text = body.message.text;

        userMessages.add(chatId); // Track users for broadcasting

        let responseText;
        try {
            if (text.startsWith('/')) {
                // Handle commands
                responseText = await handleCommand(text, chatId);
            } else {
                // Call AI API to get a response
                responseText = await getAIResponse(text);
            }

            await sendMessage(chatId, responseText);
            messageCount++;
        } catch (error) {
            console.error('Error handling message:', error);
            responseText = 'Sorry, I encountered an error while processing your request.';
            await sendMessage(chatId, responseText);
        }
    }

    return new Response('OK', { status: 200 });
}

async function handleCommand(command, chatId) {
    const normalizedCommand = command.trim().toLowerCase();

    switch (normalizedCommand) {
        case '/start':
            return 'Hello! I am your friendly chatbot. How can I assist you today?';
        case '/help':
            return `Here are some commands you can use:
/start - Start the bot
/help - Get help
/stats - View bot stats
/uptime - View bot uptime
/broadcast <message> - Send a message to all users
/status - Check bot status`;
        case '/stats':
            return `Messages processed: ${messageCount}`;
        case '/uptime':
            const uptime = formatUptime(Date.now() - startTime);
            return `Uptime: ${uptime}`;
        case '/status':
            return `Bot is up and running. Messages processed: ${messageCount}`;
        default:
            if (normalizedCommand.startsWith('/broadcast ')) {
                const broadcastMessage = normalizedCommand.substring('/broadcast '.length).trim();
                if (broadcastMessage.length > 0) {
                    await broadcastMessageToUsers(broadcastMessage);
                    return 'Broadcast message sent.';
                } else {
                    return 'Please provide a message to broadcast.';
                }
            }
            return 'Unknown command. Type /help to see available commands.';
    }
}

async function getAIResponse(text) {
    const apiKey = 'YOUR_GEMINI_API_KEY'; // Replace with your actual Gemini API key
    const apiUrl = 'https://api.gemini.com/v1/chat/completions'; // Replace with the correct API URL

    const payload = {
        model: "gemini-1.0-turbo", // Replace with the correct model name
        messages: [
            { role: "system", content: "You are a helpful assistant." },
            { role: "user", content: text }
        ],
        max_tokens: 150
    };

    const init = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify(payload)
    };

    try {
        const response = await fetch(apiUrl, init);

        if (!response.ok) {
            const errorText = await response.text();
            console.error('Error response from Gemini API:', errorText);
            return 'Sorry, I encountered an error while processing your request.';
        }

        const data = await response.json();
        if (data.choices && data.choices.length > 0) {
            return data.choices[0].message.content.trim();
        } else {
            console.error('No choices found in Gemini API response');
            return 'Sorry, I could not understand your request.';
        }
    } catch (error) {
        console.error('Error calling Gemini API:', error);
        return 'Sorry, I encountered an error while processing your request.';
    }
}

async function sendMessage(chatId, text) {
    const token = 'YOUR_TELEGRAM_BOT_TOKEN'; // Replace with your actual Telegram bot token
    const url = `https://api.telegram.org/bot${token}/sendMessage`;

    const payload = {
        chat_id: chatId,
        text: text
    };

    const init = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
    };

    try {
        const response = await fetch(url, init);
        const data = await response.json();

        if (!data.ok) {
            console.error('Error from Telegram API:', data);
        }

        return data;
    } catch (error) {
        console.error('Error sending message to Telegram:', error);
    }
}

async function broadcastMessageToUsers(message) {
    for (const chatId of userMessages) {
        try {
            await sendMessage(chatId, message);
        } catch (error) {
            console.error(`Error broadcasting message to chat ${chatId}:`, error);
        }
    }
}

function formatUptime(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    return `${days}d ${hours % 24}h ${minutes % 60}m ${seconds % 60}s`;
}
